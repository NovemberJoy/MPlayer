<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>4.2. Wyjścia video dla tradycyjnych kart graficznych</title><link rel="stylesheet" type="text/css" href="default.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="MPlayer - Odtwarzacz filmów"><link rel="up" href="video.html" title="Rozdział 4. Urządzenia wyjścia video"><link rel="prev" href="mtrr.html" title="4.1. Ustawianie MTRR"><link rel="next" href="mpeg_decoders.html" title="4.3. Dekodery MPEG"><link rel="preface" href="howtoread.html" title="Jak czytać tę dokumentację"><link rel="chapter" href="intro.html" title="Rozdział 1. Wprowadzenie"><link rel="chapter" href="install.html" title="Rozdział 2. Instalacja"><link rel="chapter" href="usage.html" title="Rozdział 3. Sposób użycia"><link rel="chapter" href="video.html" title="Rozdział 4. Urządzenia wyjścia video"><link rel="chapter" href="ports.html" title="Rozdział 5. Porty"><link rel="chapter" href="mencoder.html" title="Rozdział 6. Podstawy używania MEncodera"><link rel="chapter" href="encoding-guide.html" title="Rozdział 7. Kodowanie przy użyciu MEncodera"><link rel="chapter" href="faq.html" title="Rozdział 8. FAQ - Często Zadawane Pytania"><link rel="appendix" href="bugreports.html" title="Dodatek A. Jak zgłaszać błędy"><link rel="appendix" href="skin.html" title="Dodatek B. Format skórki MPlayera"><link rel="subsection" href="output-trad.html#xv" title="4.2.1. Xv"><link rel="subsection" href="output-trad.html#dga" title="4.2.2. DGA"><link rel="subsection" href="output-trad.html#sdl" title="4.2.3. SDL"><link rel="subsection" href="output-trad.html#svgalib" title="4.2.4. SVGAlib"><link rel="subsection" href="output-trad.html#fbdev" title="4.2.5. Wyjście bufora ramki (FBdev)"><link rel="subsection" href="output-trad.html#mga_vid" title="4.2.6. Bufor ramki Matrox (mga_vid)"><link rel="subsection" href="output-trad.html#tdfxfb" title="4.2.7. Obsługa 3dfx YUV"><link rel="subsection" href="output-trad.html#opengl" title="4.2.8. Wyjście OpenGL"><link rel="subsection" href="output-trad.html#aalib" title="4.2.9. AAlib - wyświetlanie w trybie tekstowym"><link rel="subsection" href="output-trad.html#caca" title="4.2.10. libcaca - Color ASCII Art library (biblioteka kolorowego ASCII-Art)"><link rel="subsection" href="output-trad.html#vesa" title="4.2.11. VESA - wyjście na VESA BIOS"><link rel="subsection" href="output-trad.html#x11" title="4.2.12. X11"><link rel="subsection" href="output-trad.html#vidix" title="4.2.13. VIDIX"><link rel="subsection" href="output-trad.html#directfb" title="4.2.14. DirectFB"><link rel="subsection" href="output-trad.html#dfbmga" title="4.2.15. DirectFB/Matrox (dfbmga)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.2. Wyjścia video dla tradycyjnych kart graficznych</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="mtrr.html">Poprzedni</a> </td><th width="60%" align="center">Rozdział 4. Urządzenia wyjścia video</th><td width="20%" align="right"> <a accesskey="n" href="mpeg_decoders.html">Następny</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="output-trad"></a>4.2. Wyjścia video dla tradycyjnych kart graficznych</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="xv"></a>4.2.1. Xv</h3></div></div></div><p>
W XFree86 4.0.2 lub nowszym możesz używać sprzętowego YUV poprzez
rozszerzenie XVideo. To tego używa opcja <tt class="option">-vo xv</tt>.
Ten sterownik obsługuje także regulację jasności/kontrastu/nasycenia/itp.
(chyba, że używasz starego, powolnego kodeka DirectShow DivX,
który to obsługuje wszędzie). Spójrz na stronę man.
</p><p>
Aby to zadziałało upewnij się, że:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
  Masz XFree86 4.0.2 lub nowsze (starsze nie mają XVideo)
</p></li><li class="listitem"><p>
  Twoja karta obsługuje przyśpieszanie sprzętowe (współczesne karty to robią)
</p></li><li class="listitem"><p>
  X ładuje rozszerzenie XVideo, zwykle wygląda to tak:
  </p><pre class="programlisting">(II) Loading extension XVideo</pre><p>
  w <tt class="filename">/var/log/XFree86.0.log</tt>
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Uwaga</h3><p>
   To ładuje tylko rozszerzenie XFree86. W dobrej instalacji
   jest to zawsze włączone i nie oznacza to że obsługa XVideo w
   <span class="bold"><strong>karcie</strong></span> jest załadowana.
  </p></div><p>
</p></li><li class="listitem"><p>
  Twoja karta obsługuje Xv pod Linuksem. Aby sprawdzić, spróbuj
  <span class="command"><strong>xvinfo</strong></span>, wchodzące w skład dystrybucji XFree86.
  Powinno wyświetlić długi tekst podobny do tego:
  </p><pre class="screen">
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
(...)
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
(...etc...)</pre><p>
  Karta musi obsługiwać formaty "YUY2 packed" i "YV12 planar",
  aby mogła być używana z <span class="application">MPlayerem</span>.
</p></li><li class="listitem"><p>
  I na koniec sprawdź, czy <span class="application">MPlayer</span>
  został skompilowany z obsługą Xv.
  Wykonaj <span class="command"><strong>mplayer -vo help | grep xv </strong></span>.
  Jeżeli została wbudowana obsługa Xv to powinien się pojawić podobny wiersz:
  </p><pre class="screen">
  xv      X11/Xv</pre><p>
</p></li></ol></div><p>
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="tdfx"></a>4.2.1.1. Karty 3dfx</h4></div></div></div><p>
Starsze sterowniki 3dfx znane były z tego, że miały problemy z akceleracją
XVideo.
Nie obsługiwały ani przestrzeni kolorów YUY2, ani YV12. Sprawdź czy masz
XFree86 w wersji 4.2.0 lub nowszej, działają one dobrze z YV12 i YUY2.
Poprzednie wersje, z 4.1.0 włącznie,
<span class="bold"><strong>wywalały się na YV12</strong></span>.
Jeżeli napotkasz na dziwne działanie używając <tt class="option">-vo xv</tt>,
spróbuj SDL (także ma XVideo) i zobacz, czy to pomaga.
Dokładniejsze instrukcje są w sekcji <a class="link" href="output-trad.html#sdl" title="4.2.3. SDL">SDL</a>.
</p><p>
<span class="bold"><strong>LUB</strong></span>, spróbuj NOWEGO sterownika
<tt class="option">-vo tdfxfb</tt>!
Zajrzyj do sekcji <a class="link" href="output-trad.html#tdfxfb" title="4.2.7. Obsługa 3dfx YUV">tdfxfb</a>
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="s3"></a>4.2.1.2. Karty S3</h4></div></div></div><p>
S3 Savage3D powinny działać. Jeżeli masz Savage4 używaj XFree86 4.0.3 lub
nowszego (gdyby występowały problemy z obrazem, spróbuj ustawić głębię kolorów
na 16bpp).
Jeżeli chodzi o S3 Virge: obsługuje ona Xv, ale jest bardzo wolna,
więc najlepiej ją sprzedaj.
</p><p>
Teraz dostępny jest natywny sterownik bufora ramek (framebuffer) dla
kart S3 Virge, podobny do tdfxfb. Ustaw swój bufor ramek (np. dodaj
"<tt class="option">vga=792 video=vesa:mtrr</tt>" do parametrów swojego kernela)
i używaj <tt class="option">-vo s3fb</tt> (<tt class="option">-vf yuy2</tt>
i <tt class="option">-dr</tt> także mogą okazać się przydatne).
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Uwaga</h3><p>
Obecnie niejasne jest, które modele kart Savage nie mają sprzętowej obsługi
YV12 i robią to programowo (co jest wolne). Jeżeli podejrzewasz o to swoją
kartę, zdobądź nowsze sterowniki, lub grzecznie poproś o sterownik z obsługą
MMX/3DNow! na liście dyskusyjnej MPlayer-users.
</p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="nvidia"></a>4.2.1.3. Karty nVidia</h4></div></div></div><p>
nVidia nie zawsze jest dobrym wyborem dla Linuksa ...
Sterownik XFree86 o otwartych źródłach obsługuje większość tych kart, lecz
w niektórych wypadkach będziesz zmuszony używać binarnych sterowników
o zamkniętych źródłach (do pobrania ze
<a class="ulink" href="http://www.nvidia.com/object/linux.html" target="_top">strony nVidii</a>).
Jeżeli chcesz uzyskać przyspieszenie 3D to zawsze będziesz potrzebować tych
sterowników.
</p><p>
karty Riva 128 nie obsługują XVideo nawet ze sterownikami nVidii :(
Zażalenia składaj do nVidii.
</p><p>
Jednakże <span class="application">MPlayer</span> zawiera sterownik
<a class="link" href="output-trad.html#vidix" title="4.2.13. VIDIX">VIDIX</a> obsługujący większość kart nVidia.
Obecnie znajduje się w stadium beta i ma pewne ograniczenia.
Więcej informacji znajdziesz w sekcji <a class="link" href="output-trad.html#vidix-nvidia" title="4.2.13.5. Karty nVidia">nVidia VIDIX</a>.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="ati"></a>4.2.1.4. Karty ATI</h4></div></div></div><p>
<a class="ulink" href="http://gatos.sf.net" target="_top">Sterowniki GATOS</a>
(których powinieneś używać, chyba że masz Rage128 lub Radeon)
mają standardowo włączone VSYNC. Znaczy to, że szybkość dekodowania (!)
jest zsynchronizowana z częstotliwością odświeżania obrazu.
Jeżeli odtwarzanie wydaje Ci się powolne,
spróbuj w jakiś sposób wyłączyć VSYNC,
lub ustaw częstotliwość odświeżania na n*(fps filmu) Hz.
</p><p>
Radeon VE - jeżeli potrzebujesz X, używaj XFree86 4.2.0 lub nowszego.
Brak obsługi wyjścia TV.
Oczywiście w <span class="application">MPlayerze</span> możesz uzyskać
<span class="bold"><strong>przyśpieszane</strong></span> wyświetlanie,
z lub bez <span class="bold"><strong>wyjścia TV</strong></span>.
Żadne biblioteki czy X nie są do tego potrzebne.
Poczytaj sekcję o <a class="link" href="output-trad.html#vidix" title="4.2.13. VIDIX">VIDIX</a>.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="neomagic"></a>4.2.1.5. Karty NeoMagic</h4></div></div></div><p>
Te karty można znaleźć w wielu laptopach.
Musisz używać XFree86 4.3.0 lub nowszych, lub sterowników Stefana Seyfried'a
<a class="ulink" href="http://www.mplayerhq.hu/MPlayer/contrib/NeoMagic-driver/" target="_top">
obsługujących Xv</a>.
Po prostu wybierz ten, który pasuje do Twojej wersji XFree86.
</p><p>
XFree86 4.3.0 zawierają obsługę Xv, lecz Bohdan Horst wysłał małą
<a class="ulink" href="http://www.mplayerhq.hu/MPlayer/contrib/NeoMagic-driver/neo_driver.patch" target="_top">łatkę</a>
na źródła XFree86, która przyśpiesza operacje na buforze ramki (framebuffer)
nawet czterokrotnie. Ta łatka została uwzględniona w XFree86 CVS
i powinna znaleźć się w następnej wersji po 4.3.0
</p><p>
Aby umożliwić odtwarzanie zawartości o rozmiarach DVD zmodyfikuj
swój XF86Config w następujący sposób:
</p><pre class="programlisting">
Section "Device"
    [...]
    Driver "neomagic"
    <span class="emphasis"><em>Option "OverlayMem" "829440"</em></span>
    [...]
EndSection</pre><p>
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="trident"></a>4.2.1.6. Karty Trident</h4></div></div></div><p>
Jeżeli chcesz używać Xv z kartą Trident, to jeśli nie działa z 4.1.0,
zainstaluj XFree 4.2.0. 4.2.0 obsługuje pełnoekranowe Xv
w karcie Cyberblade XP.
</p><p>
Alternatywą jest sterownik <a class="link" href="output-trad.html#vidix" title="4.2.13. VIDIX">VIDIX</a> dla
karty Cyberblade/i1.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="kyro"></a>4.2.1.7. Karty Kyro/PowerVR</h4></div></div></div><p>
Jeżeli chcesz używać Xv z kartą opartą na Kyro
(na przykład Hercules Prophet 4000XT), powinieneś ściągnąć sterowniki ze
<a class="ulink" href="http://www.powervr.com/" target="_top">strony PowerVR</a>.
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="dga"></a>4.2.2. DGA</h3></div></div></div><p><b>WSTĘP. </b>
Celem tego dokumentu jest wyjaśnienie w kilku słowach, czym ogólnie jest DGA
i co może zrobić sterownik do <span class="application">MPlayera</span>
(i czego nie może).
</p><p><b>CO TO JEST DGA. </b>
<acronym class="acronym">DGA</acronym> to skrót od <span class="emphasis"><em>Direct Graphics Access
(Bezpośredni Dostęp do Grafiki)</em></span> i jest dla programu sposobem
ominięcia serwera X i bezpośrednią modyfikację pamięci bufora ramki
(framebuffer). Technicznie mówiąc, działa to w ten sposób,
że pamięć bufora ramki mapowana jest na zakres pamięci Twojego procesu.
Jądro pozwala na to tylko gdy masz prawa administratora (superuser).
Możesz je uzyskać logując się jako
<code class="systemitem">root</code> lub ustawiając bit SUID
na pliku wykonywalnym <span class="application">MPlayera</span>
(<span class="bold"><strong>nie zalecane</strong></span>).
</p><p>
Istnieją dwie wersje DGA: DGA1 używane przez XFree 3.x.x i DGA2,
które pojawiło się w XFree 4.0.1.
</p><p>
DGA1 zapewnia jedynie bezpośredni dostęp do bufora ramki,
w sposób opisany powyżej.
Aby zmienić rozdzielczość sygnału video będziesz musiał polegać na
rozszerzeniu XVidMode.
</p><p>
DGA2 łączy cechy rozszerzenia XVidMode z możliwością zmiany głębi wyświetlania,
więc możesz mając uruchomiony serwer X w 32 bitowej głębi przełączać się na
15 bitów i vice versa.
</p><p>
Jednakże DGA ma pewne wady. Jest poniekąd zależne od układu graficznego
jakiego używasz, a także od implementacji sterownika video (w serwerze X)
sterującego układem. Nie działa to więc na każdym systemie...
</p><p><b>INSTALOWANIE OBSŁUGI DGA W MPLAYERZE. </b>
Przede wszystkim upewnij się, że X ładuje rozszerzenie DGA. Spójrz na
<tt class="filename">/var/log/XFree86.0.log</tt>:

</p><pre class="programlisting">(II) Loading extension XFree86-DGA</pre><p>

XFree86 4.0.x lub nowsze jest <span class="bold"><strong>wysoce wskazane</strong></span>!
Sterownik DGA <span class="application">MPlayera</span> jest wykrywany automatycznie
przez <tt class="filename">./configure</tt>. Możesz także wymusić jego obsługę
poprzez <tt class="option">--enable-dga</tt>.
</p><p>
Jeżeli sterownik nie mógł przełączyć się na niższą rozdzielczość,
poeksperymentuj z opcjami <tt class="option">-vm</tt> (tylko w X 3.3.x),
<tt class="option">-fs</tt>, <tt class="option">-bpp</tt>, <tt class="option">-zoom</tt>
aby znaleźć tryb wyświetlania, który odpowiada filmowi.
Na razie nie ma żadnego konwertera :(
</p><p>
Stań się użytkownikiem <code class="systemitem">root</code>.
DGA wymaga praw superużytkownika, aby móc zapisywać bezpośrednio do pamięci video.
Jeżeli chcesz posługiwać się DGA jako zwykły użytkownik, zainstaluj
<span class="application">MPlayera</span> w trybie SUID root:

</p><pre class="screen">
chown root <em class="replaceable"><code>/usr/local/bin/mplayer</code></em>
chmod 750 <em class="replaceable"><code>/usr/local/bin/mplayer</code></em>
chmod +s <em class="replaceable"><code>/usr/local/bin/mplayer</code></em>
</pre><p>
Teraz DGA działa także dla zwykłego użytkownika.
</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Zagrożenie bezpieczeństwa</h3><p>
To jest <span class="bold"><strong>poważne</strong></span> zagrożenie bezpieczeństwa!
<span class="bold"><strong>Nigdy</strong></span>
nie rób tego na serwerze, ani na komputerze dostępnym dla innych osób,
ponieważ mogą one zdobyć prawa roota poprzez
<span class="application">MPlayera</span> z ustawionym SUID root.
</p></div><p>
Teraz użyj opcji <tt class="option">-vo dga</tt> i już! (mam nadzieję:)
Powinieneś także spróbować czy działa u Ciebie opcja
<tt class="option">-vo sdl:driver=dga</tt>! Jest wiele szybsza!
</p><p><a name="dga-modelines"></a><b>ZMIANA ROZDZIELCZOŚCI. </b>
Sterownik DGA zezwala na zmianę rozdzielczości sygnału wyjściowego.
Eliminuje to potrzebę (wolnego) programowego skalowania i
równocześnie zapewnia wyświetlanie pełnoekranowe.
W warunkach idealnych rozdzielczość zostałaby zmieniona na dokładnie taką samą
(z zachowaniem formatu obrazu) jak dane video,
ale serwer X pozwala stosować tylko tryby predefiniowane w
<tt class="filename">/etc/X11/XF86Config</tt>
(<tt class="filename">/etc/X11/XF86Config-4</tt> dla XFree 4.X.X).
Są one definiowane przez tak zwane "modelines" (wiersze trybów) i zależą od
możliwości Twojego sprzętu.
serwer X skanuje przy starcie ten plik konfiguracyjny
i wyłącza tryby nie pasujące do Twojego sprzętu. Aby się dowiedzieć,
które tryby przetrwały ten proces sprawdź plik
<tt class="filename">/var/log/XFree86.0.log</tt>.
</p><p>
Te wpisy działają z układem Riva128, przy użyciu modułu sterownika nv.o
(moduł serwera X):
</p><pre class="programlisting">
Section "Modes"
  Identifier "Modes[0]"
  Modeline "800x600"  40     800 840 968 1056  600 601 605 628
  Modeline "712x600"  35.0   712 740 850 900   400 410 412 425
  Modeline "640x480"  25.175 640 664 760 800   480 491 493 525
  Modeline "400x300"  20     400 416 480 528   300 301 303 314 Doublescan
  Modeline "352x288"  25.10  352 368 416 432   288 296 290 310
  Modeline "352x240"  15.750 352 368 416 432   240 244 246 262 Doublescan
  Modeline "320x240"  12.588 320 336 384 400   240 245 246 262 Doublescan
EndSection
</pre><p><b>DGA i MPLAYER. </b>
DGA jest używane w dwóch miejscach w <span class="application">MPlayerze</span>:
można go używać przez sterownik SDL (<tt class="option">-vo sdl:driver=dga</tt>)
oraz bezpośrednio przez sterownik DGA (<tt class="option">-vo dga</tt>).
To, co zostało napisane powyżej, jest prawdziwe dla obu;
w następnych sekcjach wyjaśnię, jak działa sterownik DGA dla
<span class="application">MPlayera</span>.
</p><p><b>WŁASNOŚCI. </b>
Sterownik DGA wywoływany jest poprzez podanie <tt class="option">-vo dga</tt>
w wierszu poleceń.
Standardowym zachowaniem jest zmiana rozdzielczości na jak najbardziej
pasującą do obrazu.
Świadomie ignorowane są opcje <tt class="option">-vm</tt> i <tt class="option">-fs</tt>
(zmiana trybu wyświetlania oraz wyświetlanie pełnoekranowe) - sterownik zawsze
próbuje pokryć jak największą powierzchnię ekranu poprzez zmianę trybu
wyświetlania, dzięki temu nie marnuje mocy procesora na skalowanie obrazu.
Jeżeli nie podoba Ci się dobrany tryb, możesz sam go określić,
korzystając z opcji <tt class="option">-x</tt> oraz <tt class="option">-y</tt>.
Jeżeli podasz opcję <tt class="option">-v</tt>,
sterownik DGA wyświetli między innymi listę wszystkich obsługiwanych
w tej chwili trybów, dostępnych w Twoim pliku konfiguracyjnym
<tt class="filename">XF86Config</tt>.
Mając DGA2 możesz zmusić je także do wyświetlania obrazu w określonej głębi,
używając opcji <tt class="option">-bpp</tt>.
Prawidłowymi głębiami są 15, 16, 34 i 32.
Od Twojego sprzętu zależy, czy są one obsługiwane natywnie, czy też dokonywana
jest konwersja (możliwe, że powolna).
</p><p>
Jeżeli jesteś takim szczęśliwcem, że masz wystarczająco dużo pamięci
pozaekranowej (offscreen memory) aby zmieścił się tam cały obraz,
sterownik DGA użyje podwójnego buforowania.
Efektem będzie płynniejsze odtwarzanie filmu.
Sterownik poinformuje Cię czy podwójne buforowanie jest włączone czy nie.
</p><p>
Podwójne buforowanie oznacza, że następna ramka Twojego filmu jest rysowana
w pamięci pozaekranowej w czasie gdy obecna ramka jest wyświetlana.
Gdy następna ramka będzie gotowa, układ graficzny zostanie poinformowany
o lokalizacji nowej ramki w pamięci i po prostu sięgnie tam po dane
aby je wyświetlić.
W międzyczasie poprzedni bufor w pamięci zostanie ponownie wypełniony
kolejnymi danymi video.
</p><p>
Podwójne buforowanie może być włączane opcją
<tt class="option">-double</tt> oraz może być wyłączane opcją
<tt class="option">-nodouble</tt>.
Obecnie standardowym zachowaniem jest wyłączone podwójne buforowanie.
Jeśli używasz sterownika DGA wyświetlanie OSD
(On Screen Display - wyświetlanie na ekranie)
działa wyłącznie z włączonym podwójnym buforowaniem.
Jednakże włączenie podwójnego buforowania może zaowocować dużym spadkiem
szybkości (na moim K6-II+ 525 używało dodatkowe 20% czasu procesora!)
w zależności od implementacji DGA dla Twojego sprzętu.
</p><p><b>KWESTIA SZYBKOŚCI. </b>
Ogólnie rzecz biorąc, dostęp do bufora ramki poprzez DGA powinien być
przynajmniej tak szybki, jak podczas używania sterownika X11,
z dodatkową korzyścią uzyskania pełnoekranowego obrazu.
Procentowe wartości szybkości wyświetlane przez
<span class="application">MPlayera</span> należy interpretować ostrożnie.
Na przykład przy korzystaniu ze sterownika X11 nie jest uwzględniany czas
potrzebny serwerowi X na rysowanie.
Podłącz terminal do portu szeregowego swojego komputera i uruchom
<span class="command"><strong>top</strong></span> aby zobaczyć co się na prawdę dzieje w Twoim komputerze.
</p><p>
Generalnie przyśpieszenie przy używaniu DGA w stosunku do
"normalnego"
używania X11 bardzo zależy od Twojej karty graficznej i od tego, jak dobrze
zoptymalizowany jest moduł do serwera X.
</p><p>
Jeżeli masz wolny system, lepiej używaj 15 lub 16 bitowej
głębi kolorówi, ponieważ wymaga ona tylko połowy przepustowości pamięci
w porównaniu do głębi 32 bitowej.
</p><p>
Używanie 24 bitowej głębi jest dobrym pomysłem, nawet jeśli
Twoja karta natywnie obsługuje tylko 32 bitową głębię, ponieważ 24 bitowa
głębia przesyła 25% mniej danych w porównaniu do w pełni 32 bitowego trybu.
</p><p>
Widziałem pewne pliki AVI odtwarzane na Pentium MMX 266.
Na AMD K6-2 powinno działać od 400MHz.
</p><p><b>ZNANE BŁĘDY. </b>
Według niektórych deweloperów XFree DGA jest niezłą bestią.
Mówią oni, że lepiej go nie używać, ponieważ jego implementacja nie zawsze
jest bezbłędna dla każdego sterownika XFree.
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
  Istnieje błąd związany z XFree 4.0.3 i sterownikiem <tt class="filename">nv.o</tt>
  objawiający się dziwnymi kolorami.
</p></li><li class="listitem"><p>
  Sterowniki ATI wymagają wielokrotnego przełączania trybu po użyciu DGA.
</p></li><li class="listitem"><p>
  Niektóre sterowniki po prostu nie wracają do normalnej rozdzielczości (użyj
  <span class="keycap"><b>Ctrl</b></span>+<span class="keycap"><b>Alt</b></span>+<span class="keycap"><b>Keypad +</b></span> oraz
  <span class="keycap"><b>Ctrl</b></span>+<span class="keycap"><b>Alt</b></span>+<span class="keycap"><b>Keypad -</b></span>
  aby przełączać się ręcznie).
</p></li><li class="listitem"><p>
  Niektóre sterowniki wyświetlają dziwne kolory.
</p></li><li class="listitem"><p>
  Niektóre sterowniki kłamią na temat rozmiaru pamięci,
  którą mapują na przestrzeń adresową procesu.
  Przez to vo_dga nie będzie używać podwójnego buforowania (SIS?).
</p></li><li class="listitem"><p>
  Niektóre sterowniki nie zwracają żadnego poprawnego trybu.
  W tym wypadku sterownik DGA się wywali mówiąc Ci o bezsensownym
  trybie 100000x100000 (lub podobnym).
</p></li><li class="listitem"><p>
  OSD działa tylko z włączonym podwójnym buforowaniem (w przeciwnym razie
  migocze).
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sdl"></a>4.2.3. SDL</h3></div></div></div><p>
<acronym class="acronym">SDL</acronym> (Simple Directmedia Layer) jest w gruncie rzeczy
zunifikowanym interfejsem video/audio.
Programy, które go używają, wiedzą tylko o SDL,
a nie o sterownikach audio lub video, których używa SDL.
Na przykład port Dooma używający SDL może działać korzystając z
svgalib, aalib, X, fbdev i innych, musisz tylko określić (na przykład)
sterownik video, którego chcesz użyć.
Wybór następuje poprzez zmienną środowiskową <code class="envar">SDL_VIDEODRIVER</code>.
No, teoretycznie.
</p><p>
W <span class="application">MPlayerze</span> używaliśmy programowego skalowania
sterownika SDL dla X11, dla kart/sterowników, które nie obsługują XVideo,
dopóki nie zrobiliśmy własnego (szybszego, lepszego) programowego skalowania.
Używaliśmy także jego wyjścia aalib, ale teraz mamy własny sterownik,
który jest wygodniejszy. Jego tryb DGA był lepszy od naszego... aż do niedawna.
Rozumiesz już? :)
</p><p>
Pomaga także z niektórymi wadliwymi sterownikami/kartami w przypadku, gdy
odtwarzanie kuleje (nie z powodu wolnego systemu) lub gdy dźwięk jest opóźniony.
</p><p>
Wyjście video SDL obsługuje wyświetlanie napisów pod filmem, na czarnym pasku
(jeżeli obecny).
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="svgalib"></a>4.2.4. SVGAlib</h3></div></div></div><p><b>INSTALACJA. </b>
Będziesz musiał zainstalować svgalib i jej pakiet rozwojowy, aby
<span class="application">MPlayer</span> zbudował swój własny sterownik
SVGAlib (automatycznie wykrywane, lecz można wymusić).
Nie zapomnij przerobić <tt class="filename">/etc/vga/libvga.config</tt>, tak aby
svgalib współdziałało z Twoją kartą i monitorem.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Uwaga</h3><p>
Nie używaj opcji <tt class="option">-fs</tt> ponieważ włącza ona
skalowanie programowe, które jest powolne. Jeżeli naprawdę tego potrzebujesz,
używaj opcji <tt class="option">-sws 4</tt>,
która produkuje obraz złej jakości, ale jest nieco szybsza.
</p></div><p><b>OBSŁUGA EGA (4BPP). </b>
SVGAlib zawiera EGAlib i <span class="application">MPlayer</span>
może wyświetlać każdy film w 16 kolorach.
Użyteczne jest to w następujących zestawieniach:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
  karta EGA z monitorem EGA: 320x200x4bpp, 640x200x4bpp, 640x350x4bpp
</p></li><li class="listitem"><p>
  karta EGA z monitorem CGA: 320x200x4bpp, 640x200x4bpp
</p></li></ul></div><p>
bpp (bity na piksel) musi być ręcznie ustawione na 4: <tt class="option">-bpp 4</tt>
</p><p>
Film prawdopodobnie musi być przeskalowany tak, aby pasował do trybu EGA:
</p><pre class="screen">-vf scale=640:350</pre><p>
lub
</p><pre class="screen">-vf scale=320:200</pre><p>
</p><p>
Aby to osiągnąć, musimy sięgnąć po metodę skalowania szybką, lecz złej jakości:
</p><pre class="screen">-sws 4</pre><p>
</p><p>
Możliwe, że trzeba wyłączyć automatyczną korekcję proporcji obrazu:
</p><pre class="screen">-noaspect</pre><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Uwaga</h3><p>
Z praktyki wiem, że najlepszą jakość obrazu na ekranach EGA można
osiągnąć poprzez lekkie zmniejszenie jasności:
<tt class="option">-vf eq=-20:0</tt>. Musiałem także zmniejszyć częstotliwość
próbkowania, ponieważ dźwięk 44kHz był popsuty: <tt class="option">-srate 22050</tt>.
</p></div><p>
OSD i napisy możesz włączyć tylko przy pomocy filtru
<tt class="option">expand</tt>. Dokładne parametry znajdziesz na stronie man.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fbdev"></a>4.2.5. Wyjście bufora ramki (FBdev)</h3></div></div></div><p>
<tt class="filename">./configure</tt> automatycznie wykrywa, czy zbudować
wyjście FBdev. Więcej informacji znajdziesz w dokumentacji bufora
ramki w źródłach jądra (<tt class="filename">Documentation/fb/*</tt>).
</p><p>
Jeżeli Twoja karta nie obsługuje standardu VBE 2.0 (starsze karty ISA/PCI,
takie jak S3 Trio64), lecz VBE 1.2 (lub starsze?): cóż, pozostaje VESAfb,
ale będziesz musiał załadować SciTech Display Doctor
(dawniej UniVBE) przed zabootowaniem Linuksa.
Użyj dyskietki startowej DOS lub czegoś innego.
Nie zapomnij zarejestrować swojej kopii UniVBE ;))
</p><p>
Wyjście FBdev przyjmuje kilka dodatkowych parametrów:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><tt class="option">-fb</tt></span></dt><dd><p>
    Określa urządzanie bufora ramki, którego użyć (domyślnie: <tt class="filename">/dev/fb0</tt>)
  </p></dd><dt><span class="term"><tt class="option">-fbmode</tt></span></dt><dd><p>
    Nazwa trybu do użycia (zgodnie z <tt class="filename">/etc/fb.modes</tt>)
  </p></dd><dt><span class="term"><tt class="option">-fbmodeconfig</tt></span></dt><dd><p>
    Plik konfiguracyjny trybów (domyślnie: <tt class="filename">/etc/fb.modes</tt>)
  </p></dd><dt><span class="term"><tt class="option">-monitor-hfreq</tt>, </span><span class="term"><tt class="option">-monitor-vfreq</tt>, </span><span class="term"><tt class="option">-monitor-dotclock</tt></span></dt><dd><p>
    <span class="bold"><strong>ważne</strong></span> wartości, patrz
    <tt class="filename">example.conf</tt>
  </p></dd></dl></div><p>
Jeżeli chcesz się przełączyć na określony tryb, użyj
</p><pre class="screen">
mplayer -vm -fbmode <em class="replaceable"><code>nazwa_trybu</code></em> <em class="replaceable"><code>nazwa_pliku</code></em>
</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
  Samo <tt class="option">-vm</tt> wybierze najbardziej odpowiedni tryb z
  <tt class="filename">/etc/fb.modes</tt>. Można użyć także wraz z opcjami
  <tt class="option">-x</tt> oraz <tt class="option">-y</tt>. Opcja
  <tt class="option">-flip</tt> jest obsługiwana wyłącznie gdy format
  (pixel format) filmu pasuje do formatu (pixel format) obrazu.
  Zwróć uwagę na wartość bpp. Sterownik fbdev próbuje użyć bieżącej wartości,
  chyba że użyjesz opcji <tt class="option">-bpp</tt>.
</p></li><li class="listitem"><p>
  Opcja <tt class="option">-zoom</tt> nie jest obsługiwana
  (użyj <tt class="option">-vf scale</tt>). Nie możesz używać trybów 8bpp (lub mniej).
</p></li><li class="listitem"><p>
  Możesz chcieć wyłączyć kursor:
  </p><pre class="screen">echo -e '\033[?25l'</pre><p>
  lub
  </p><pre class="screen">setterm -cursor off</pre><p>
  oraz wygaszacz ekranu:
  </p><pre class="screen">setterm -blank 0</pre><p>
  Aby z powrotem włączyć kursor:
  </p><pre class="screen">echo -e '\033[?25h'</pre><p>
  lub
  </p><pre class="screen">setterm -cursor on</pre><p>
</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Uwaga</h3><p>
Zmiana trybów FBdev <span class="emphasis"><em>nie działa</em></span> z buforem ramki VESA,
i nie proś o to, ponieważ nie jest to ograniczenie
<span class="application">MPlayera</span>.
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mga_vid"></a>4.2.6. Bufor ramki Matrox (mga_vid)</h3></div></div></div><p>
Ta sekcja traktuje o obsłudze układu BES (Back-End Scaler) na kartach
Matrox G200/G400/G450/G550 przez sterownik
<code class="systemitem">mga_vid</code> z jądra.
Ma on sprzętowy VSYNC z potrójnym buforowaniem.
Działa na konsoli framebuffer oraz w X.
</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Ostrzeżenie</h3><p>
Tylko dla Linuksa! Na systemach nie-Linuksowych (testowane na FreeBSD) używaj
zamiast tego <a class="link" href="output-trad.html#vidix" title="4.2.13. VIDIX">VIDIX</a>!
</p></div><div class="procedure"><a name="idm1655"></a><p class="title"><b>Instalacja</b></p><ol class="procedure" type="1"><li class="step"><p>
  Przed użyciem musisz skompilować <tt class="filename">mga_vid.o</tt>:
  </p><pre class="screen">
cd drivers
make</pre><p>
</p></li><li class="step"><p>
  Następnie stwórz urządzenie (device) <tt class="filename">/dev/mga_vid</tt>:
  </p><pre class="screen">mknod /dev/mga_vid c 178 0</pre><p>
  oraz załaduj sterownik poprzez:
  </p><pre class="screen">insmod mga_vid.o</pre><p>
</p></li><li class="step"><p>
  Powinieneś sprawdzić rozmiar wykrywanej pamięci używając polecenia
  <span class="command"><strong>dmesg</strong></span>.
  Jeżeli zwracana wartość jest zła użyj opcji:
  <tt class="option">mga_ram_size</tt>
  (najpierw <span class="command"><strong>rmmod mga_vid</strong></span>),
  podaj rozmiar pamięci na karcie (w MB):
  </p><pre class="screen">insmod mga_vid.o mga_ram_size=16</pre><p>
</p></li><li class="step"><p>
  Aby moduł był ładowany/usuwany automatycznie w razie potrzeby:
  najpierw wstaw następujący wiersz na końcu
  <tt class="filename">/etc/modules.conf</tt>:

  </p><pre class="programlisting">alias char-major-178 mga_vid</pre><p>

  Następnie skopiuj moduł <tt class="filename">mga_vid.o</tt>
  we właściwe miejsce w <tt class="filename">/lib/modules/<em class="replaceable"><code>wersja jądra</code></em>/<em class="replaceable"><code>gdzieś</code></em></tt>.
  </p><p>
  Po czym uruchom
  </p><pre class="screen">depmod -a</pre><p>
</p></li><li class="step"><p>
  Teraz musisz (ponownie) skompilować <span class="application">MPlayera</span>,
  <tt class="filename">./configure</tt> wykryje
  <tt class="filename">/dev/mga_vid</tt> i zbuduje sterownik "mga".
  Używanie go w <span class="application">MPlayerze</span> uzyskuje się poprzez
  <tt class="option">-vo mga</tt> jeżeli masz konsolę matroxfb, lub
  <tt class="option">-vo xmga</tt> pod XFree86 3.x.x lub 4.x.x.
</p></li></ol></div><p>
Sterownik mga_vid współpracuje z Xv.
</p><p>
Plik urządzenia (device file) <tt class="filename">/dev/mga_vid</tt>
może być odczytywany aby uzyskać pewne informacje,
na przykład poprzez </p><pre class="screen">cat /dev/mga_vid</pre><p>
i można do niego pisać, by zmienić jasność:
</p><pre class="screen">echo "brightness=120" &gt; /dev/mga_vid</pre><p>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="tdfxfb"></a>4.2.7. Obsługa 3dfx YUV</h3></div></div></div><p>
Ten sterownik używa bufora ramki tdfx w jądrze aby odtwarzać filmy
z przyśpieszeniem YUV. Będziesz potrzebował jądra z obsługą tdfxfb. Będziesz
także musiał odpowiednio skompilować <span class="application">MPlayera</span>.
</p><pre class="screen">./configure --enable-tdfxfb</pre><p>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="opengl"></a>4.2.8. Wyjście OpenGL</h3></div></div></div><p>
<span class="application">MPlayer</span> obsługuje wyświetlanie filmów używając
OpenGL, lecz jeśli Twoja platforma/sterownik obsługuje Xv,
jak powinno być w przypadku PeCetów z Linuksem, używaj Xv.
Wydajność OpenGL jest znacząco mniejsza.
Jeżeli masz implementację X11 bez obsługi Xv, OpenGL jest sensowną alternatywą.
</p><p>
Niestety nie wszystkie sterowniki to obsługują.
Sterowniki Utah-GLX (dla XFree86 3.3.6) obsługują to w każdej karcie.
Szczegóły ich instalacji dostępne są na stronie
<a class="ulink" href="http://utah-glx.sf.net" target="_top">http://utah-glx.sf.net</a>.
</p><p>
XFree86(DRI) 4.0.3 i nowsze obsługują OpenGL w kartach Matrox i Radeon,
4.2.0 i nowsze obsługują Rage128. Na <a class="ulink" href="http://dri.sf.net" target="_top">http://dri.sf.net</a>
znajdziesz instrukcję ściągania i instalacji.
</p><p>
Podpowiedź od jednego z naszych użytkowników: wyjście video GL może
być użyte aby uzyskać wyjście TV z vsync. Będziesz musiał ustawić
zmienną środowiskową (przynajmniej dla nVidia):
</p><p>
<span class="command"><strong>export __GL_SYNC_TO_VBLANK=1</strong></span>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="aalib"></a>4.2.9. AAlib - wyświetlanie w trybie tekstowym</h3></div></div></div><p>
AAlib jest biblioteką do wyświetlania grafiki w trybie tekstowym,
używając potężnego silnika renderującego ASCII. Istnieje
<span class="emphasis"><em>wiele</em></span> programów już ją obsługujących, takich jak Doom,
Quake, etc. <span class="application">MPlayer</span> zawiera świetnie działający
sterownik. Jeżeli <tt class="filename">./configure</tt> wykryje zainstalowane
aalib, zostanie zbudowany sterownik aalib libvo.
</p><p>
Możesz używać następujących klawiszy w oknie AA, aby zmienić opcje renderowania:
</p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Klawisz</th><th>Akcja</th></tr></thead><tbody><tr><td><span class="keycap"><b>1</b></span></td><td>
  zmniejsz kontrast
</td></tr><tr><td><span class="keycap"><b>2</b></span></td><td>
  zwiększ kontrast
</td></tr><tr><td><span class="keycap"><b>3</b></span></td><td>
  zmniejsz jasność
</td></tr><tr><td><span class="keycap"><b>4</b></span></td><td>
  zwiększ jasność
</td></tr><tr><td><span class="keycap"><b>5</b></span></td><td>
  włącz/wyłącz szybkie renderowanie
</td></tr><tr><td><span class="keycap"><b>6</b></span></td><td>
  ustaw tryb ditheringu (brak, error distribution, Floyd Steinberg)
</td></tr><tr><td><span class="keycap"><b>7</b></span></td><td>
  odwróć obraz
</td></tr><tr><td><span class="keycap"><b>8</b></span></td><td>
  przełączanie kontroli między aa i <span class="application">MPlayerem</span>
</td></tr></tbody></table></div><div class="variablelist"><p class="title"><b>Następujące opcje mogą być użyte w wierszu poleceń:</b></p><dl class="variablelist"><dt><span class="term"><tt class="option">-aaosdcolor=<em class="replaceable"><code>V</code></em></tt></span></dt><dd><p>
    zmiana koloru OSD
  </p></dd><dt><span class="term"><tt class="option">-aasubcolor=<em class="replaceable"><code>V</code></em></tt></span></dt><dd><p>
    Zmiana koloru napisów
    </p><p>
    gdzie <em class="replaceable"><code>V</code></em> jest jednym z:
    <code class="literal">0</code> (normalny),
    <code class="literal">1</code> (ciemny),
    <code class="literal">2</code> (pogrubiony),
    <code class="literal">3</code> (pogrubiona czcionka),
    <code class="literal">4</code> (odwrócony),
    <code class="literal">5</code> (specjalny).
  </p></dd></dl></div><div class="variablelist"><p class="title"><b>AAlib samo w sobie ma wiele opcji. Poniżej znajduje się
kilka ważniejszych:</b></p><dl class="variablelist"><dt><span class="term"><tt class="option">-aadriver</tt></span></dt><dd><p>
    Ustawia sugerowany sterownik aa (X11, curses, Linux)
  </p></dd><dt><span class="term"><tt class="option">-aaextended</tt></span></dt><dd><p>
    Używa wszystkich 256 znaków.
  </p></dd><dt><span class="term"><tt class="option">-aaeight</tt></span></dt><dd><p>
    Używa 8-bitowego ASCII
  </p></dd><dt><span class="term"><tt class="option">-aahelp</tt></span></dt><dd><p>
    Wyświetla wszystkie opcje aalib
  </p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Uwaga</h3><p>
Renderowanie bardzo obciąża CPU, zwłaszcza przy użyciu AA-on-X (aalib w X),
a zajmuje mniej CPU na standardowej, nie-framebufferowej konsoli.
Użyj SVGATextMode, aby ustawić duży tryb tekstowy i baw się dobrze!
(drugi monitor z kartą Hercules wymiata:))
(ale moim skromnym zdaniem możesz użyć opcji
<tt class="option">-vf 1bpp</tt> aby uzyskać grafikę na hgafb:)
</p></div><p>
Użyj opcji <tt class="option">-framedrop</tt>, jeżeli Twój komputer nie jest na tyle
szybki, aby wyrenderować wszystkie ramki!
</p><p>
Odtwarzając w terminalu osiągniesz lepszą szybkość i jakość używając sterownika
Linux, a nie curses (<tt class="option">-aadriver linux</tt>).
Jednakże będziesz potrzebował praw zapisu na
<tt class="filename">/dev/vcsa<em class="replaceable"><code>&lt;terminal&gt;</code></em></tt>!
Nie jest to wykrywane automatycznie przez aalib, ale vo_aa próbuje
znaleźć najlepszy tryb. Spójrz na
<a class="ulink" href="http://aa-project.sf.net/tune" target="_top">http://aa-project.sf.net/tune</a>,
jest tam więcej informacji o dostrajaniu.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="caca"></a>4.2.10. <code class="systemitem">libcaca</code> - Color ASCII Art library (biblioteka kolorowego ASCII-Art)</h3></div></div></div><p>
Biblioteka <a class="ulink" href="http://sam.zoy.org/projects/libcaca/" target="_top"><code class="systemitem">libcaca</code></a>
jest bibiloteką produkującą tekst zamiast pikseli, może więc pracować na
starszych kartach graficznych oraz terminalach tekstowych. Jest podobna do
słynnej biblioteki <code class="systemitem">AAlib</code>.
<code class="systemitem">libcaca</code> potrzebuje do pracy terminalu,
powinna więc działać na wszystkich systemach Uniksowych (włącznie z Mac OS X),
używając biblioteki
<code class="systemitem">slang</code> lub biblioteki
<code class="systemitem">ncurses</code>, w DOSie używając biblioteki
<code class="systemitem">conio.h</code> i w systemach Windowsowych
używając <code class="systemitem">slang</code> lub
<code class="systemitem">ncurses</code> (poprzez emulację Cygwin) bądź
<code class="systemitem">conio.h</code>. Jeżeli
<tt class="filename">./configure</tt>
wykryje <code class="systemitem">libcaca</code>, to zostanie zbudowany
sterownik caca libvo.
</p><div class="itemizedlist"><p class="title"><b>Różnice między <code class="systemitem">AAlib</code> są
  następujące:</b></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
  16 dostępnych kolorów na wyjściu znakowym (256 par kolorów)
</p></li><li class="listitem"><p>
  dirthering obrazu kolorowego
</p></li></ul></div><div class="itemizedlist"><p class="title"><b>Lecz <code class="systemitem">libcaca</code> ma także
  następujące ograniczenia:</b></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
  brak obsługi jasności, kontrastu, gammy
</p></li></ul></div><p>
Aby zmienić opcje renderowania, możesz użyć następujących klawiszy w oknie caca:
</p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col><col></colgroup><thead><tr><th>Klawisz</th><th>Akcja</th></tr></thead><tbody><tr><td><span class="keycap"><b>d</b></span></td><td>
  Przełączanie metod ditheringu <code class="systemitem">libcaca</code>.
</td></tr><tr><td><span class="keycap"><b>a</b></span></td><td>
  Przełączanie anyaliasingu (wygładzania)
  <code class="systemitem">libcaca</code>.
</td></tr><tr><td><span class="keycap"><b>b</b></span></td><td>
  Przełączanie tła <code class="systemitem">libcaca</code>.
</td></tr></tbody></table></div><div class="variablelist"><p class="title"><b><code class="systemitem">libcaca</code> będzie także szukać
  następujących zmiennych środowiskowych:</b></p><dl class="variablelist"><dt><span class="term"><tt class="option">CACA_DRIVER</tt></span></dt><dd><p>
    Ustawia zalecany sterownik caca, np. ncurses, slang, x11.
  </p></dd><dt><span class="term"><tt class="option">CACA_GEOMETRY (tylko X11)</tt></span></dt><dd><p>
    Określa liczbę wierszy i kolumn, np. 128x50.
  </p></dd><dt><span class="term"><tt class="option">CACA_FONT (tylko X11)</tt></span></dt><dd><p>
    Określa jakiej użyć czcionki, np. fixed, nexus.
  </p></dd></dl></div><p>
Jeżeli Twój komputer nie jest wystarczająco szybki, aby renderować
wszystkie ramki, użyj opcji <tt class="option">-framedrop</tt>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="vesa"></a>4.2.11. VESA - wyjście na VESA BIOS</h3></div></div></div><p>
Ten sterownik został zaprojektowany i napisany jako
<span class="bold"><strong>ogólny sterownik</strong></span> dla dowolnej karty,
która ma BIOS zgodny z VESA VBE 2.0. Inną zaletą tego sterownika jest to,
że próbuje on wymusić włączenie wyjścia TV.
<em class="citetitle">VESA BIOS EXTENSION (VBE) Version 3.0, z dnia 16 września 1998</em>
(Strona 70) mówi:
</p><div class="blockquote"><blockquote class="blockquote"><p><b>Podwójne kontrolery (Dual-Controller Designs). </b>
VBE 3.0 obsługuje podwójne kontrolery zakładając, że zwykle obydwa kontrolery
są dostarczane przez tego samego OEM, pod kontrolą pojedynczego ROM BIOSu
na karcie graficznej. Jest możliwe ukrycie przed aplikacją,
że obecne są dwa kontrolery. Ograniczeniem tego jest brak możliwości
równoczesnego używania niezależnych kontrolerów, ale pozwala aplikacjom
wypuszczonym przed VBE 3.0 na normalne działanie.
Funkcja VBE 00h (zwróć informację o kontrolerze) zwraca połączone
informacje o obydwóch kontrolerach, włącznie z połączoną listą
dostępnych trybów.
Gdy aplikacja wybiera tryb, włączany jest odpowiedni kontroler.
Każda z pozostałych funkcji VBE operuje później na aktywnym kontrolerze.
</p></blockquote></div><p>
Są więc szanse, że używając tego sterownika uzyskasz działające wyjście TV.
(Zgaduję, że często wyjście TV jest samodzielnym układem (standalone head),
lub przynajmniej samodzielnym wyjściem.)
</p><div class="itemizedlist"><p class="title"><b>ZALETY</b></p><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
  Jest szansa, że będziesz mógł oglądać filmy
  <span class="bold"><strong>nawet, gdy Linux nie wie</strong></span>, jakiego sprzętu używasz.
</p></li><li class="listitem"><p>
  Nie ma potrzeby instalowania jakichkolwiek rzeczy związanych z grafiką
  (takich jak X11 (AKA XFree86), fbdev i tak dalej) na Twoim Linuksie.
  Ten sterownik można uruchamiać z <span class="bold"><strong>trybu tekstowego</strong></span>.
</p></li><li class="listitem"><p>
  Jest szansa że uzyskasz <span class="bold"><strong>działające wyjście TV</strong></span>.
  (Jest tak przynajmniej w przypadku kart ATI).
</p></li><li class="listitem"><p>
  Ten sterownik wywołuje procedurę obsługi przerwania 10h
  (<code class="function">int 10h</code> handler), nie jest więc emulatorem -
  odwołuje się do <span class="bold"><strong>rzeczywistych</strong></span> rzeczy
  <span class="emphasis"><em>rzeczywistego</em></span> BIOSu w
  <span class="emphasis"><em>trybie rzeczywistym (real-mode)</em></span>. (tak naprawdę,
  to w trybie vm86, ale działa równie szybko).
</p></li><li class="listitem"><p>
  Możesz używać VIDIX, uzyskując przez to przyśpieszone wyświetlanie video
  <span class="bold"><strong>oraz</strong></span> wyjście TV w tym samym czasie!
  (Zalecane dla kart ATI.)
</p></li><li class="listitem"><p>
  Jeżeli masz VESA VBE 3.0+ i określiłeś gdzieś
  <tt class="option">monitor-hfreq, monitor-vfreq, monitor-dotclock</tt>
  (w pliku konfiguracyjnym lub w wierszu poleceń), uzyskasz najwyższą możliwą
  częstotliwość odświeżania (Używając General Timing Formula
  (Ogólnej Formuły Taktowania)). Aby to włączyć, musisz określić
  <span class="bold"><strong>wszystkie</strong></span> opcje monitora.
</p></li></ul></div><div class="itemizedlist"><p class="title"><b>WADY</b></p><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
  Działa tylko na <span class="bold"><strong>systemach x86</strong></span>.
</p></li><li class="listitem"><p>
  Może być używane tylko przez użytkownika
  <code class="systemitem">root</code>.
</p></li><li class="listitem"><p>
  Obecnie jest dostępne tylko dla <span class="bold"><strong>Linuksa</strong></span>.
</p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Ważne</h3><p>
Nie używaj tego sterownika wraz z <span class="bold"><strong>GCC 2.96</strong></span>!
Nie będzie działać!
</p></div><div class="variablelist"><p class="title"><b>OPCJE WIERSZA POLECEŃ DLA VESA</b></p><dl class="variablelist"><dt><span class="term"><tt class="option">-vo vesa:<em class="replaceable"><code>opts</code></em></tt></span></dt><dd><p>
    obecnie rozpoznawane: <code class="literal">dga</code>, aby wymusić tryb dga oraz
    <code class="literal">nodga</code>, aby wyłączyć tryb dga. W trybie dga możesz
    włączyć podwójne buforowanie
    opcją <tt class="option">-double</tt>. Informacja: możesz pominąć
    te parametry, aby włączyć <span class="bold"><strong>automatyczne wykrywanie
    </strong></span> trybu dga.
  </p></dd></dl></div><div class="itemizedlist"><p class="title"><b>ZNANE PROBLEMY I ICH OBEJŚCIA</b></p><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
  Jeżeli zainstalowałeś czcionkę <span class="bold"><strong>NLS
  (Native Language Support - Obsługa Języka Rodzimego)</strong></span>
  w swoim Linuksie i używasz sterownika VESA z trybu tekstowego to po
  zakończeniu <span class="application">MPlayera</span> będziesz miał załadowaną
  <span class="bold"><strong>czcionkę ROM</strong></span> zamiast narodowej.
  Możesz z powrotem załadować czcionkę narodową używając na przykład narzędzia
  <span class="command"><strong>setsysfont</strong></span> z dystrybucji Mandrake/Mandriva.
  (<span class="bold"><strong>Podpowiedź</strong></span>:
  To samo narzędzie jest używane do lokalizacji fbdev).
</p></li><li class="listitem"><p>
  Niektóre <span class="bold"><strong>Linuksowe sterowniki grafiki</strong></span>
  nie aktualizują aktywnego <span class="bold"><strong>trybu BIOS</strong></span>
  w pamięci DOS.  Więc jeżeli masz taki problem - zawsze używaj trybu VESA
  tylko z <span class="bold"><strong>trybu tekstowego</strong></span>.
  W przeciwnym wypadku tryb tekstowy (#03) i tak będzie włączany
  i będziesz musiał restartować komputer.
</p></li><li class="listitem"><p>
  Często po zakończeniu pracy sterownika VESA dostajesz
  <span class="bold"><strong>czarny</strong></span> ekran.
  Aby przywrócić ekran do stanu oryginalnego po prostu przełącz się na
  inną konsolę (wciskając <span class="keycap"><b>Alt</b></span>+<span class="keycap"><b>F&lt;x&gt;</b></span>)
  po czym przełącz się z powrotem na poprzednią konsolę w ten sam sposób.
</p></li><li class="listitem"><p>
  Aby uzyskać <span class="bold"><strong>działające wyjście TV</strong></span>
  musisz mieć podłączony odbiornik TV przed włączeniem swojego PC,
  ponieważ video BIOS inicjalizuje się tylko podczas procedury POST
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="x11"></a>4.2.12. X11</h3></div></div></div><p>
Unikaj, jeśli to możliwe. Wyjście na X11 (używa rozszerzenia współdzielonej
pamięci) nie używa żadnego przyśpieszania sprzętowego.
Obsługuje (przyśpieszane przez MMX/3DNow/SSE, lecz ciągle wolne) skalowanie
programowe. Użyj opcji <tt class="option">-fs -zoom</tt>.
Większość kart ma obsługę sprzętowego skalowania, warto więc użyć dla nich
opcji <tt class="option">-vo xv</tt> lub
<tt class="option">-vo xmga</tt> dla kart Matrox.
</p><p>
Problemem jest to, że sterowniki do większości kart nie obsługują sprzętowego
przyśpieszenia na wyjściu na drugi monitor (second head)/TV.
W takim przypadku widać zielone/niebieskie okno zamiast filmu.
To tutaj przydaje się ten sterownik, lecz potrzebujesz potężnego
CPU aby używać programowego skalowania. Nie używaj programowego
wyjścia SDL + skalowania, jakość obrazu jest o wiele gorsza!
</p><p>
Skalowanie programowe jest bardzo wolne, lepiej spróbuj zmienić tryb video.
Jest to bardzo proste. Spójrz na
<a class="link" href="output-trad.html#dga-modelines" title="ZMIANA ROZDZIELCZOŚCI">wiersze trybów sekcji DGA</a>
i wstaw je do swojego <tt class="filename">XF86Config</tt>.

</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
  Jeżeli masz 4.x.x: użyj opcji <tt class="option">-vm</tt>.
  Zmieni ona rozdzielczość na taką jaką ma twój film. Jeżeli nie:
</p></li><li class="listitem"><p>
  W XFree86 3.x.x: musisz poruszać się po dostępnych rozdzielczościach
  poprzez kombinacje klawiszy
  <span class="keycap"><b>Ctrl</b></span>+<span class="keycap"><b>Alt</b></span>+<span class="keycap"><b>Keypad +</b></span>
  oraz
  <span class="keycap"><b>Ctrl</b></span>+<span class="keycap"><b>Alt</b></span>+<span class="keycap"><b>Keypad -</b></span>.
</p></li></ul></div><p>
</p><p>
Jeżeli nie możesz znaleźć trybów, które wstawiłeś, przeszukaj komunikaty
XFree86. Niektóre sterowniki nie mogą używać niskich pixelclock
(częstotliwości taktowania układu RAMDAC), które są wymagane dla trybów
o niskiej rozdzielczości.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="vidix"></a>4.2.13. VIDIX</h3></div></div></div><p><b>WSTĘP. </b>
<acronym class="acronym">VIDIX</acronym> jest skrótem od
<span class="bold"><strong>VID</strong></span>eo
<span class="bold"><strong>I</strong></span>nterface
for *ni<span class="bold"><strong>X</strong></span>
(Interfejs VIDeo dla *niXów).
VIDIX został zaprojektowany i napisany jako interfejs dla szybkich
sterowników działających w przestrzeni
użytkownika (user-space), zapewniających taką samą wydajność, jak mga_vid
dla kart Matrox. Jest także wysoce przenośny (portable).
</p><p>
Ten interfejs został zaprojektowany jako próba dopasowania istniejących
interfejsów przyśpieszanego video
(znanych jako mga_vid, rage128_vidm radeon_vid, pm3_vid) do ustalonego
schematu. Zapewnia wysokopoziomowy interfejs dla układów znanych jako BES
(BackEnd Scalers)
lub OV (Video Overlay - nakładka video).
Nie zapewnia on niskopoziomowego interfejsu do tworów znanych jako serwery
grafiki. (nie chcę współzawodniczyć z zespołem X11 w przełączaniu trybów
graficznych). Innymi słowy,
głównym celem tego interfejsu jest maksymalizacja szybkości odtwarzania video.
</p><div class="itemizedlist"><p class="title"><b>ZASTOSOWANIE</b></p><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
  Możesz używać samodzielnego sterownika wyjścia video:
  <tt class="option">-vo xvidix</tt>. Ten sterownik został stworzony jako
  interfejs X11
  dla technologii VIDIX. Wymaga serwera X i może pracować tylko pod nim.
  Zwróć uwagę na to, że stosowany jest bezpośredni dostęp do sprzętu
  i omijany jest sterownik X, pixmapy przechowywane (cached) w pamięci karty
  mogą zostać uszkodzone. Możesz temu zapobiec ograniczając ilość używanej przez
  X pamięci poprzez opcję "VideoRam" w sekcji "device".
  Powinieneś ustawić to na rozmiar pamięci na karcie minus 4MB.
  Jeżeli masz mniej niż 8MB pamięci video (video RAM),
  możesz użyć zamiast tego opcji "XaaNoPixmapCache" w sekcji "screen".
</p></li><li class="listitem"><p>
  Istnieje konsolowy sterownik VIDIX: <tt class="option">-vo cvidix</tt>.
  Wymaga on dla większości kart działającego i zainicjalizowanego bufora ramki
  (albo po prostu zapaskudzisz sobie ekran). Otrzymasz podobny efekt jak przy
  <tt class="option">-vo mga</tt> lub <tt class="option">-vo fbdev</tt>. Jednakże karty nVidia
  są zdolne do wyświetlania w pełni graficznego obrazu w konsoli całkowicie
  tekstowej. Więcej informacji znajdziesz w sekcji
  <a class="link" href="output-trad.html#vidix-nvidia" title="4.2.13.5. Karty nVidia">nvidia_vid</a>.
  Żeby pozbyć się tekstu na ramkach i mrugającego kursora, wypróbuj coś w rodzaju
  </p><pre class="screen">setterm -cursor off &gt; /dev/tty9</pre><p>
  (zakładając, że do tej pory nie używałeś <code class="systemitem">tty9</code>)
  a potem przełącz się na <code class="systemitem">tty9</code>.
  Z drugiej strony, <tt class="option">-colorkey 0</tt> powinno dać video odtwarzające
  się "w tle", chociaż działanie tego zależy od prawidłowego funkcjonowania
  koloru kluczowego.
</p></li><li class="listitem"><p>
  Możesz użyć podurządzenia (subdevice) VIDIX, które zostało dodane
  do rozmaitych sterowników wyjścia video, takich jak:
  <tt class="option">-vo vesa:vidix</tt>
  (<span class="bold"><strong>tylko Linux</strong></span>)
  oraz <tt class="option">-vo fbdev:vidix</tt>.
</p></li></ul></div><p>
W rzeczywistości nie ma znaczenia, który sterownik wyjścia video jest używany z
<span class="bold"><strong>VIDIX</strong></span>.
</p><div class="itemizedlist"><p class="title"><b>WYMAGANIA</b></p><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
  Karta graficzna powinna pracować w trybie graficznym (z wyjątkiem kart nVidia
  z w/w sterownikiem wyjścia <tt class="option">-vo cvidix</tt>).
</p></li><li class="listitem"><p>
  Sterownik wyjścia video <span class="application">MPlayera</span> powinien znać
  aktywny tryb video, a także powinien być w stanie przekazać podurządzeniu
  VIDIX niektóre cechy serwera.
</p></li></ul></div><p><b>METODY UŻYWANIA. </b>
Gdy VIDIX używany jest jako <span class="bold"><strong>podurządzenie</strong></span>
(<tt class="option">-vo vesa:vidix</tt>) konfiguracja trybu video jest dokonywana
przez urządzenie wyjścia video (w skrócie
<span class="bold"><strong>vo_server</strong></span>).
Możesz więc przekazać <span class="application">MPlayerowi</span>
takie same ustawienia jak dla vo_server.
Dodatkowo rozumie on ustawienie <tt class="option">-double</tt>
jako globalnie widoczny parametr.
(Zalecam używanie tego ustawienia z VIDIX przynajmniej dla kart ATI).
Jeżeli chodzi o <tt class="option">-vo xvidix</tt>, to obecnie rozpoznaje następujące
opcje <tt class="option">-fs -zoom -x -y -double</tt>.
</p><p>
Możesz także określić sterownik VIDIX jako trzeci podargument w wierszu poleceń:

</p><pre class="screen">mplayer -vo xvidix:mga_vid.so -fs -zoom -double <em class="replaceable"><code>plik.avi</code></em></pre><p>
lub
</p><pre class="screen">mplayer -vo vesa:vidix:radeon_vid.so -fs -zoom -double -bpp 32 <em class="replaceable"><code>plik.avi</code></em></pre><p>

Ale jest to niebezpieczne i nie powinieneś tego robić.
W tym przypadku podany sterownik zostanie wymuszony i rezultat może być
nieprzewidywalny (może <span class="bold"><strong>zawiesić</strong></span> Twój komputer).
Powinieneś to robić TYLKO, jeśli jesteś całkowicie pewien, że zadziała,
a <span class="application">MPlayer</span> nie robi tego automatycznie.
Proszę, powiadom o tym deweloperów. Prawidłowym sposobem jest używanie VIDIX
bez żadnych argumentów, aby umożliwić automatyczne wykrywanie sterownika.
</p><p>
Ponieważ VIDIX wymaga bezpośredniego dostępu do sprzętu, musisz uruchamiać
<span class="application">MPlayera</span> jako root lub ustawić bit SUID na binarce
<span class="application">MPlayera</span>
(<span class="bold"><strong>Ostrzeżenie: Jest to zagrożenie bezpieczeństwa!</strong></span>).
Alternatywnie możesz używać specjalnego modułu jądra, takiego jak ten:
</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
  Ściągnij <a class="ulink" href="http://www.arava.co.il/matan/svgalib/" target="_top">rozwojową wersję</a>
  svgalib (na przykład 1.9.17) <span class="bold"><strong>LUB</strong></span> ściągnij
  <a class="ulink" href="http://www.mplayerhq.hu/MPlayer/contrib/svgalib/svgalib_helper-1.9.17-mplayer.tar.bz2" target="_top">stąd</a>
  wersję stworzoną przez Alexa specjalnie do użytku z <span class="application">MPlayerem</span>
  (nie potrzebuje ona do kompilacji źródeł svgalib)
</p></li><li class="step"><p>
  Skompiluj moduł w katalogu <tt class="filename">svgalib_helper</tt>
  (jeżeli ściągnąłeś źródła ze strony svgalib to można go znaleźć wewnątrz katalogu
  <tt class="filename">svgalib-1.9.17/kernel/</tt>) i załaduj go (insmod).
</p></li><li class="step"><p>
  Aby utworzyć odpowiednie urządzenia (devices) w katalogu <tt class="filename">/dev</tt>,
  wykonaj jako root </p><pre class="screen">make device</pre><p> w katalogu <tt class="filename">svgalib_helper</tt>.
</p></li><li class="step"><p>
  Przenieś katalog <tt class="filename">svgalib_helper</tt> do
  <tt class="filename">mplayer/main/libdha/svgalib_helper</tt>.
</p></li><li class="step"><p>
  Wymagane jeżeli ściągnąłeś źródła ze strony svgalib: usuń komentarz przed
  wierszem CFLAGS zawierający ciąg "svgalib_helper" z
  <tt class="filename">libdha/Makefile</tt>.
</p></li><li class="step"><p>
  Przekompiluj i zainstaluj libdha
</p></li></ol></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-ati"></a>4.2.13.1. Karty ATI</h4></div></div></div><p>
Obecnie większość kart ATI jest obsługiwana natywnie,
od Mach64 do najnowszych Radeonów.
</p><p>
Są dwie skompilowanie binarki: <tt class="filename">radeon_vid</tt> dla Radeonów
oraz <tt class="filename">rage128_vid</tt> dla kart Rage 128.
Możesz wymusić jedną z nich lub pozwolić systemowi VIDIX na autodetekcję
dostępnych sterowników.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-mga"></a>4.2.13.2. Karty Matrox</h4></div></div></div><p>
Matrox G200, G400, G450 i G550 zgłoszono jako działające.
</p><p>
Sterownik obsługuje korektory (equalizery) video i powinien być prawie tak
szybki jak <a class="link" href="output-trad.html#mga_vid" title="4.2.6. Bufor ramki Matrox (mga_vid)">bufor ramki Matrox</a>
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-trident"></a>4.2.13.3. Karty Trident</h4></div></div></div><p>
Jest dostępny sterownik dla układu Trident Cyberblade/i1, który można znaleźć
na płytach głównych VIA Epia.
</p><p>
Sterownik ten został napisany przez (i jest pod opieką)
<a class="ulink" href="http://www.blackfiveservices.co.uk/EPIAVidix.shtml" target="_top">Alastaira M. Robinsona</a>.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-3dlabs"></a>4.2.13.4. Karty 3DLabs</h4></div></div></div><p>
Chociaż istnieje sterownik dla układów 3DLabs GLINT R3 oraz Permedia3,
to nikt go nie testował (sprawozdania są mile widziane).
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-nvidia"></a>4.2.13.5. Karty nVidia</h4></div></div></div><p>
Unikalną cechą sterownika nvidia_vid jest jego zdolność do wyświetlania obrazu
na <span class="bold"><strong>zwykłej, czysto tekstowej konsoli</strong></span> - bez
magicznych X, bufora ramki, czy czegokolwiek.
W tym celu będziemy musieli użyć wyjścia video <tt class="option">cvidix</tt>, jak
w pokazuje poniższy przykład:
  </p><pre class="screen">mplayer -vo cvidix <em class="replaceable"><code>przyklad.avi</code></em></pre><p>
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="vidix-sis"></a>4.2.13.6. Karty SiS</h4></div></div></div><p>
Jest to kod wysoce eksperymentalny, tak jak nvidia_vid.
</p><p>
Przetestowano go na SiS 650/651/740 (najczęściej używane układy w
minimalistycznych pecetach "Shuttle XPC" z płytami
SiS).
</p><p>
Czekamy na raporty!
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="directfb"></a>4.2.14. DirectFB</h3></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>
"DirectFB jest biblioteką graficzną, która była tworzona z myślą o
systemach typu embedded.
Oferuje ona maksymalną przyśpieszaną sprzętowo wydajność przy minimalnym
zużyciu zasobów i minimalnym narzucie biblioteki.
" - cytat z <a class="ulink" href="http://www.directfb.org" target="_top">http://www.directfb.org</a>
</p></blockquote></div><p>Nie będę tu podawał cech DirectFB.</p><p>
Chociaż <span class="application">MPlayer</span> nie jest obsługiwany jako
"dostawca video" dla DirectFB,
ten sterownik wyjścia umożliwi odtwarzanie video poprzez DirectFB.
Będzie ono - oczywiście - przyśpieszane.
Na moim Matroksie G400 szybkość DirectFB była taka sama jak XVideo.
</p><p>
Zawsze próbuj używać najnowszej wersji DirectFB.
Możesz używać opcji DirectFB w wierszu poleceń, używając opcji
<tt class="option">-dfbopts</tt>. Wyboru warstwy można dokonać metodą podurządzenia.
Przykład: <tt class="option">-vo directfb:2</tt> (standardową jest warstwa -1 : autodetekcja)
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="dfbmga"></a>4.2.15. DirectFB/Matrox (dfbmga)</h3></div></div></div><p>
Przeczytaj proszę <a class="link" href="output-trad.html#directfb" title="4.2.14. DirectFB">główną sekcję DirectFB</a>,
znajdziesz tam ogólne informacje.
</p><p>
Ten sterownik wyjścia video włączy CRTC2
(na drugim wyjściu z karty) w kartach Matrox G400/G450/G550,
wyświetlając obraz <span class="bold"><strong>niezależnie</strong></span>
od pierwszego wyjścia z karty.
</p><p>
Ville Syrjala ma na swojej stronie domowej
<a class="ulink" href="http://www.sci.fi/~syrjala/directfb/Matrox_TV-out_README.txt" target="_top">README</a>
oraz
<a class="ulink" href="http://www.sci.fi/~syrjala/directfb/matrox-tv-out-howto" target="_top">HOWTO</a>
wyjaśniające, jak uruchomić wyjście TV DirectFB w kartach Matrox.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Uwaga</h3><p>
Pierwszą wersją DirectFB, jaką udało nam się uruchomić była 0.9.17
(wadliwa, potrzebuje łatki <code class="systemitem">surfacemanager</code>
z powyższego URL).
Port kodu CRTC2 do
<a class="link" href="output-trad.html#mga_vid" title="4.2.6. Bufor ramki Matrox (mga_vid)">mga_vid</a> jest od lat w planach.
Mile widziane są
<a class="ulink" href="../../tech/patches.txt" target="_top">łatki</a>.
</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="mtrr.html">Poprzedni</a> </td><td width="20%" align="center"><a accesskey="u" href="video.html">Początek rozdziału</a></td><td width="40%" align="right"> <a accesskey="n" href="mpeg_decoders.html">Następny</a></td></tr><tr><td width="40%" align="left" valign="top">4.1. Ustawianie MTRR </td><td width="20%" align="center"><a accesskey="h" href="index.html">Spis treści</a></td><td width="40%" align="right" valign="top"> 4.3. Dekodery MPEG</td></tr></table></div></body></html>
